# Матрица тестирования MCP tools (mcp-lsp-bridge)

✅ Skill used: `mcp-testing`

Цель: проверить, что каждый tool **делает ровно то, что заявлено**, на **реальных BSL-модулях** из `test-workspace`, и что ошибки/краевые случаи обрабатываются предсказуемо.

## Общие договорённости

- **Среда**: MCP запущен в контейнере `mcp-lsp-bridge-universal`, workspace внутри контейнера: `/projects/test-workspace`.
- **URI формат**: во всех LSP-like tools используем `file:///projects/test-workspace/...`.
- **Режим работы**: LSP-клиент поднимается **автоматически** при `initialize` MCP-сервера (без `lsp_connect`).
  - Если самый первый вызов tool вернул статус `starting/busy` с `retry_after_ms`, это не ошибка — повторяем запрос после паузы.
- **Файлы можно менять смело**: весь `/projects/test-workspace` — копия выгрузки, будет удалён после тестов.

## Тестовые файлы (fixtures)

Выбраны из реального `test-workspace` (проверено, что файлы существуют внутри контейнера):

- **F1 (общий модуль приложения)**: `/projects/test-workspace/Ext/SessionModule.bsl`
- **F2 (модуль менеджера)**: `/projects/test-workspace/AccumulationRegisters/_ДемоОстаткиТоваровВМестахХранения/Ext/ManagerModule.bsl`
- **F3 (модуль набора записей)**: `/projects/test-workspace/AccountingRegisters/_ДемоЖурналПроводокБухгалтерскогоУчета/Ext/RecordSetModule.bsl`

Для тестов с координатами (line/character) позиции уточняем по факту через `get_range_content` (первые ~200 строк) и фиксируем в этом файле после первого прогона.

---

## 1) `get_range_content`

- **Для чего**: вытащить кусок текста файла (точная навигация/фиксация позиций).
- **Как тестируем и ситуации**:
  - **happy**: первые 200 строк F1 (0-based) → возвращает ожидаемый текст, стабильная кодировка.
  - **edge**: `strict=false` и `end_character` сильно больше длины строки → tool должен “clamp”, не падать.
  - **negative**: `strict=true` + выход за границы → ожидаем ошибку.
  - **negative**: несуществующий `uri` → понятная ошибка.

## 2) `project_analysis`

- **Для чего**: большой анализатор (symbols/refs/defs/search/patterns/workspace summary).
- **Как тестируем и ситуации**:
  - **workspace_analysis**: общий обзор `/projects/test-workspace`.
  - **text_search**: поиск уникального текста из F1, который видим через `get_range_content` → должен находить совпадения.
  - **document_symbols**: по F1 → выдаёт список процедур/функций.
  - **definitions/references**: на символе из F1 (после фиксации координат) → выдаёт ожидаемые локации.
  - **negative**: пустой/невалидный `analysis_type` → корректная ошибка.

## 3) `symbol_explore`

- **Для чего**: семантический поиск символов с фильтрацией по контексту файла.
- **Как тестируем и ситуации**:
  - **happy**: берём имя процедуры/функции из F1 и ищем `query=...` → должен найти в F1.
  - **edge**: `file_context="Ext"` → должен сузить выборку.
  - **negative**: заведомо несуществующий символ → пустой результат (не ошибка).

## 4) `document_diagnostics`

- **Для чего**: диагностика одного файла (ошибки/предупреждения).
- **Как тестируем и ситуации**:
  - **baseline**: F1/F2/F3 без изменений → ожидаем либо пусто, либо только “мягкие” предупреждения (фиксируем фактический baseline).
  - **negative**: намеренно ломаем синтаксис в одном из файлов (минимально) → ожидаем диагностическое сообщение в конкретной позиции.

## 5) `workspace_diagnostics`

- **Для чего**: диагностика всего workspace.
- **Как тестируем и ситуации**:
  - **baseline**: `/projects/test-workspace` → фиксируем baseline (может быть большой).
  - **edge**: после внесения одной синтаксической ошибки в один из файлов → ожидаем, что ошибка видна в workspace-диагностике.
  - **performance note**: замеряем время/объём ответа (чтобы не убивать агента огромными простынями).

## 6) `hover`

- **Для чего**: инфа о символе в позиции (подпись/доки/тип).
- **Как тестируем и ситуации**:
  - **happy**: позиция на имени процедуры/функции в F1 → получаем описание.
  - **edge**: позиция на локальной переменной/параметре → получаем тип/подсказку (если LS умеет).
  - **negative**: позиция на пробеле/комментарии → ожидаем пустой/нейтральный ответ, без ошибки.

## 7) `signature_help`

- **Для чего**: подсказка параметров в точке вызова.
- **Как тестируем и ситуации**:
  - **happy**: на вызове функции/процедуры в F1 (внутри скобок) → видим параметры.
  - **negative**: вне вызова → пусто/нейтрально.

## 8) `implementation`

- **Для чего**: найти реализации (актуально для интерфейсов/абстракций; в BSL может быть ограничено).
- **Как тестируем и ситуации**:
  - **probe**: ищем в F1 символ, который логично “реализуется” (если есть) → фиксируем, что отдаёт LS.
  - **expected**: если LS не поддерживает — должен возвращать пусто, а не ошибку.

## 9) `call_hierarchy`

- **Для чего**: граф вызовов (incoming/outgoing/both) для символа.
- **Как тестируем и ситуации**:
  - **outgoing**: на процедуре в F1 → видим, какие вызовы она делает.
  - **incoming**: на процедуре в F1 → кто её вызывает.
  - **negative**: на символе, который нигде не вызывается → incoming пустой.

## 10) `prepare_rename`

- **Для чего**: проверить, можно ли переименовать, и получить допустимый range.
- **Как тестируем и ситуации**:
  - **happy**: на локальной процедуре/переменной в одном из файлов → вернёт range.
  - **negative**: на ключевом слове/строке/комментарии → запрет/ошибка “rename not allowed”.

## 11) `rename`

- **Для чего**: безопасный rename по всем файлам (с preview/apply).
- **Как тестируем и ситуации**:
  - **preview**: на одном из файлов → `apply="false"` и новое имя → ожидаем список правок (workspace edit), без применения.
  - **apply**: `apply="true"` → файл реально меняется; проверяем через `get_range_content`, что изменилось только ожидаемое.
  - **negative**: невалидное имя → ошибка/отказ.

## 12) `code_actions`

- **Для чего**: “умные” действия (quickfix/refactor) в позиции/диапазоне.
- **Как тестируем и ситуации**:
  - **baseline**: на корректном коде (F1) → часто пусто или “рефактор” предложения (фиксируем).
  - **error-driven**: делаем синтаксическую/типовую ошибку в одном из файлов → ожидаем quickfix (если LS поддерживает).
  - **negative**: несуществующий URI/позиция → понятная ошибка.

---

## Что фиксируем в отчёте по каждому tool

- **Входные параметры** (uri/line/character/прочее)
- **Ожидание** (коротко, до вызова)
- **Фактический ответ** (сжимать: первые N строк + метрики)
- **Вердикт**: PASS/FAIL + что именно не совпало
- **Примечания**: если LS “не поддерживает” фичу — это отдельная категория (SUPPORTED/NOT_SUPPORTED), но не падение.

